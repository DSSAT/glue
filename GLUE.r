####The main function to automatically realize the GLUE procedure for parameter estimation for DSSAT model.####
time_test <- Sys.time()
print(paste0("Calibration started at ", time_test))

#list.of.packages <- c("rjson", "parallel")
list.of.packages <- c("parallel")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos = "http://cran.us.r-project.org")

#library(rjson)

parallel_available <- require("parallel")
library(parallel)

#################Step 1: Get the fundamental information for GLUE procedure.##############

tryCatch({

## (1) Get the name of the batch file that was generated with GenSelect.
#CultivarBatchFile<-"Prisma_GC_Avg.MZC"; 

##Which batch file generated by GenSelect should be used? This information should be given to GLUE when 
##model users decide to use this program.

## (2) Get the information about the working directory of GLUE program (WD), 
#model output storage directory (OD) and DSSAT (DSSATD).
WorkDirectory<-getwd();

#read json file
#GLUE_defs <- fromJSON(file = paste0(WorkDirectory, "/GLUEDefs.json"))
#NumberOfModelRun <- as.numeric(GLUE_defs$NumberOfModelRun)
#GLUEFlag <- as.numeric(GLUE_defs$GLUEFlag)
#CultivarBatchFile<-GLUE_defs$CultivarBatchFile;
#Cores <- GLUE_defs$Cores
#EcotypeCalibration <- GLUE_defs$EcotypeCalibration
#WD<- GLUE_defs$GLUED
#OD<- GLUE_defs$OutputD
#GD<- GLUE_defs$GenotypeD
#DSSATD <- GLUE_defs$DSSATD

SimulationControl<-read.csv(paste0(WorkDirectory,'/SimulationControl.csv'), header=T);
NumberOfModelRun <- SimulationControl[SimulationControl$Variable == "NumberOfModelRun","Value"]
GLUEFlag <- SimulationControl[SimulationControl$Variable == "GLUEFlag","Value"]
CultivarBatchFile <- SimulationControl[SimulationControl$Variable == "CultivarBatchFile","Value"]
Cores <- as.integer(SimulationControl[SimulationControl$Variable == "Cores","Value"])
EcotypeCalibration <- SimulationControl[SimulationControl$Variable == "EcotypeCalibration","Value"]
WD <- SimulationControl[SimulationControl$Variable == "GLUED","Value"]
OD<- SimulationControl[SimulationControl$Variable == "OutputD","Value"]
GD<- SimulationControl[SimulationControl$Variable == "GenotypeD","Value"]
DSSATD <- SimulationControl[SimulationControl$Variable == "DSSATD","Value"]
ModelID <- SimulationControl[SimulationControl$Variable == "ModelID","Value"]

#add slash at the end to the path if missing
WD <- ifelse(substr(WD, nchar(WD), nchar(WD)) != '/', paste0(WD,"/"), WD)
OD <- ifelse(substr(OD, nchar(OD), nchar(OD)) != '/', paste0(OD,"/"), OD)
GD <- ifelse(substr(GD, nchar(GD), nchar(GD)) != '/', paste0(GD,"/"), GD)
DSSATD <- ifelse(substr(DSSATD, nchar(DSSATD), nchar(DSSATD)) != '/', paste0(DSSATD,"/"), DSSATD)



#If "Cores "variable is not a number, it will assume the simulation will carried out on the 
#HiPerGator (SLURM job scheduler) and use CORES specified in your bash file (.sh)
if(!is.numeric(Cores) | is.na(Cores)){
  Cores = as.integer(Sys.getenv("SLURM_CPUS_ON_NODE"))
  print(paste0("Cores being used: ",Cores))
}

eval(parse(text=paste("ModelRunIndicatorPath='",OD,"ModelRunIndicator.txt'",sep = ''))); 
if(parallel_available == FALSE) {
  write("Missing parallel library required for cultivar calibration.", file = ModelRunIndicatorPath, append = T);
  return()
}

glueWarningLogFile <- file.path(OD, "GlueWarning.txt");
glueExcludedModelListFile <- file.path(WD, "GlueExcludedModels.csv");
##Path of the model run indicator file, which indicates which component of GLUE is finished so far.

#command to clean the working directory (Usually GLWork) -- removes everything but the folder BackUp and batch file
#included GLWork.txt as GLUESelect needs this file
if(OD != WD){
unlink(setdiff(list.files(OD, full.names = TRUE), 
                    list.files(OD, pattern='*C$|BackUp|dscsm048|GLWork.txt|GLwork.txt', full.names = TRUE)), 
            recursive = TRUE)
}else{
  warningMsg <- "The output folder cannot be the same as the GLUE working directory. Please inform a different output folder path."
  write(warningMsg, file = glueWarningLogFile, ncolumns=1, append = T);
  stop(warningMsg)
}

#Check if the number of cores requested is higher than the actually number of cores available. 
#If that is the case, GLUE will use the maximum number of cores - 1
detectedCores <- parallel::detectCores()
if(Cores > detectedCores){
  Cores <- detectedCores - 1
  warningMsg <- paste0("Requested more cores than what is actually available. This machine has ", detectedCores, " cores. GLUE will use ", Cores, " cores.")
  write(warningMsg, file = glueWarningLogFile, ncolumns=1, append = T);
}

##WD represents working directory. This is very important, because it is used to tell the main funtion where
##the sub-functions are. DSSATD represents the DSSAT directory. GLUED represents the GLUE directory.
##OutputD represents the output directory under DSSAT, while OD means the final output directory.
##GD ir the directory of genotype files in DSSAT.

## (3) Read the number of model runs and GLUE control flag from the "Simulation Control" file.
#library(xlsReadWrite);
#eval(parse(text = paste("SimulationControl<-read.xls('",WD,
#"/SimulationControl.xls',sheet = 'Sheet 1', rowNames = T, colNames=T)",sep = '')));

newRownames <- SimulationControl[ , 1];
rownames(SimulationControl) <- newRownames;

NumberOfModelRun<-as.numeric(SimulationControl["NumberOfModelRun", "Value"]);
write(c("The number of model runs = ",NumberOfModelRun), file = ModelRunIndicatorPath, ncolumns=2, append = F);

#Read the number of model running.
#GLUEFlag<-as.numeric(SimulationControl[2,"Value"]);

#Set the flag for whole GLUE procedure. If GLUEFlag==1, it means coefficients relative both to phenology and
#growth will be evaluated; GLUEFlag==2, only phenology will be evaluated; GLUEFlag==3, only growth will be evaluated.

## (4) Get the number of round of GLUE.
if (GLUEFlag==1)
{
StartRoundOfGLUE=1
TotalRoundOfGLUE=2;
write("GLUE will run for both phenology and growth.", file = ModelRunIndicatorPath, append = T); 
} else if (GLUEFlag==2)
{
StartRoundOfGLUE=1
TotalRoundOfGLUE=1;
write("GLUE will run for phenology only.", file = ModelRunIndicatorPath, append = T); 
} else
{
StartRoundOfGLUE=2
TotalRoundOfGLUE=2;
write("GLUE will run for growth only.", file = ModelRunIndicatorPath, append = T); 
}

#write("Which round of GLUE to be done is known...", file = ModelRunIndicatorPath, append = T); 
#In default, totally two rounds of GLUE will be conducted. In the first round, only the genetic coefficients (P1, P2, p5, PHINT)
#that can influence phenology such as anthesis date and maturity date will be estimated, while other parameters (G2, G3)
#will be fixed at their mean values derived from DSSAT database.In the second round of GLUE, G2 and G3 will be estimated based on the likelihood values derived from growth outputs
#such LAIX, HWAM, CWAM. Finally, the two partial parameter sets will be conbined together to give us a final optimal parameter set.

#If only estimated phenology dates, then only the first round GLUE will be conducted; if only estimated growth, then only the
#second round GLUE will be conducted.

## (5) Get the  name of the genotype file of current crop and the name of current model
eval(parse(text=paste("BatchFile<-readLines('",OD,CultivarBatchFile,"',n=-1)",sep = '')));
CropNameAddress<-grep('BATCH', BatchFile);
CropNameStart<-18; #
CropNameEnd<-19; #
CropName<-substr(BatchFile[CropNameAddress], CropNameStart, CropNameEnd);
write(c("Crop =",CropName), file = ModelRunIndicatorPath, ncolumns=2, append = T);
#Get the crop name in this model run.

CultivarIDStart<-20; #
CultivarIDEnd<-25; #Get the Cultivar ID number such as, "IB0001";

CultivarNameStart<-20;
CultivarNameEnd<-nchar(BatchFile[CropNameAddress]); #Get the Cultivar name such as, "ZA0002 Prisma GC Avg";

CultivarID<-substr(BatchFile[CropNameAddress], CultivarIDStart, CultivarIDEnd);
CultivarName<-substr(BatchFile[CropNameAddress], CultivarNameStart, CultivarNameEnd);
write(c("Cultivar ID =",CultivarName), file = ModelRunIndicatorPath, ncolumns=2, append = T);


CTR_file_GLUE <- readLines(paste0(WD,"DSSCTR.template"))

#Check if there is already a DSCSM048.CTR inside the folder and save it.

#ECTR <- file.exists(paste0(DSSATD,"/DSCSM048.CTR"))
#if (ECTR == TRUE){
#  CTR_file_Original <- readLines(paste0(DSSATD,"/DSCSM048.CTR"))
#}

#Copy the template for applying the modifications
CTR <- CTR_file_GLUE

LineNo <- grep("GLUEModel", CTR)

LineSplit = unlist(strsplit(CTR[LineNo]," "))

LineSplit[length(LineSplit)] <- gsub("\\d+", "",ModelID)
CTR[LineNo] <- paste(LineSplit, collapse=' ')
#writeLines(CTR,paste0(DSSATD,"/DSCSM048.CTR"))

ModelSelect <- ModelID

write(c("Model Name =",ModelSelect), file = ModelRunIndicatorPath, ncolumns=2, append = T);

# Check is model is in the exclusion list
eval(parse(text=paste("excludedFile<-readLines('",glueExcludedModelListFile,"',n=-1)",sep = '')));
excludedFile.df <- read.table(textConnection(excludedFile[-c(1,2)]),header=F, sep=",")
colnames(excludedFile.df) <- unlist(strsplit(sub("@", "", excludedFile[2]), split = ","))
if (CropName %in% excludedFile.df[which(substr(ModelSelect,1,5) == excludedFile.df[,"MODEL"]),][,"CROP"]) {
  #errorMsg <- paste0("Currently model ", ModelSelect, " for ", CropName, " is not supported by GLUE, please modify the DSSATPRO.L48 file to change to other model for crop ", CropName, ".")
  errorMsg <- paste0("Currently model ", ModelSelect, " for ", CropName, " is not supported by GLUE, please select a different model for crop ", CropName, ".")
  write(errorMsg, file = glueWarningLogFile, ncolumns=1, append = T);
  # stop(errorMsg)
  quit()
}

# Get the genotype file name
GenotypeFilePath<-GD;
CurrentGenotypeFile<-paste0(GD,CropName,substr(ModelSelect,3,8),".CUL")

#Get the names of the genotype file template that will be used, which shoud start with crop name such as "MZ",
#and end with extension name ".CUL". Since there are two genotype files starting with "MZ" and ending with
#".CUL" under the "Genotype" folder of DSSAT, it was set as "MZCER048.CUL" as default value.

StringLength<-nchar(CurrentGenotypeFile);
GenotypeFileNameStartPosition<-(StringLength-(8+4)+1);
GenotypeFileNameEndPosition<-StringLength-4;
#Where 4 is the length of character ".CUL", 
#while 8 is the length of cultivar file name, such as "MZCER048".

GenotypeFileName<-substr(CurrentGenotypeFile, GenotypeFileNameStartPosition, GenotypeFileNameEndPosition);
write(c("Genotype file name =",GenotypeFileName), file = ModelRunIndicatorPath, ncolumns=2, append = T);
#Get the name of the genotype file used currently.

## (6) Set up batch file.
##Only copy the information below @FILEX in the genotype file generated by GenSelect, such as "APPOLO.MZC",
##to the batch file template "DSSBatch.template". Thus a new batch file can be generated and save it as
##"DSSBatch.v48" in the output directory.

eval(parse(text=paste("source('",WD,"BatchFileSetUp.r')",sep = '')));
BatchFileSetUp(WD, OD, CultivarBatchFile);
write(c("DSSAT batch file =",CultivarBatchFile), file = ModelRunIndicatorPath, ncolumns=2, append = T);

## (7) Get the parameter property file (miminum, maximum, and flg values) and the number of parameters.
CulFile.origin= readLines(paste0(GD,GenotypeFileName,".CUL"))#, encoding="UTF-8")

if(length(grep("999991 MINIMA", CulFile.origin)) == 0){
  errorMsg <- "Lower bound (MINIMA) not specified in the cultivar file. Please correct the file."
  return(NULL)
}
if(length(grep("999992 MAXIMA", CulFile.origin)) == 0){
  errorMsg <- "Upper bound (MAXIMA) not specified in the cultivar file. Please correct the file."
  return(NULL)
}
if(length(grep("!Calibration", CulFile.origin)) == 0){
  errorMsg <- "Missing the calibration switches (P/G/N) in the cultivar file. Please correct the file."
  return(NULL)
}

caliLine = CulFile.origin[which(substr(CulFile.origin,1,12) == "!Calibration")]
CulFile = CulFile.origin[-which(substr(CulFile.origin,1,1) == "!")] #ignore lines starting with !
CulFile = c(CulFile,caliLine)

#locate parameter properties
LineNo.title = grep("@VAR#",CulFile)[1]
LineNo.min = grep("999991 MINIMA",CulFile)
LineNo.max = grep("999992 MAXIMA",CulFile)
LineNo.cal = grep("!Calibration",CulFile)
Lineno.thiscul = grep(paste0("^",CultivarID),CulFile)

LineNo.all = c(LineNo.cal[1],LineNo.title,LineNo.min,LineNo.max,Lineno.thiscul)

if(length(LineNo.cal)>1){
  LineNo.cal = grep("!Calibration",CulFile)[1]
  warning("Please use the first !Calibration line to define the calibration switch!")
}

CulFile = CulFile[LineNo.all]
write(c("Parameter property:",CulFile ), file = ModelRunIndicatorPath, append = T);

# convert text to dataframe
CulFile.df = paste0(substr(CulFile,1,6), substr(CulFile,30,nchar(CulFile)[1]))
Cul.Header = unlist(strsplit(CulFile.df[2],split="(\\s|\\|)+"))
Cul.Header = Cul.Header[which(nchar(Cul.Header)>0)]
CulData = read.table(textConnection(CulFile.df[-c(1,2)]),header=F)
Cul.Header = Cul.Header[1:length(colnames(CulData))]
colnames(CulData) = Cul.Header

Cul.Cali = unlist(strsplit(CulFile[1],"\\s+"))
Cul.Cali.reshape = paste(c(Cul.Cali[1],"placeholder", Cul.Cali[2:length(Cul.Cali)]), sep=" ", collapse = " ")
Cul.Cali.df = read.table(textConnection(Cul.Cali.reshape),header = F)
colnames(Cul.Cali.df) = Cul.Header
Cul.Cali.df = Cul.Cali.df[1:length(Cul.Header)]
CulData = rbind(CulData,Cul.Cali.df)

ncol.predefined = which(Cul.Header=="ECO#")
Cul.TotalParameterNumber = ncol(CulData) - ncol.predefined #Get the total number of the parameters.
Cul.ParameterNames = Cul.Header[-c(1:ncol.predefined)]
write(c("Cultivar File Parameters =",Cul.ParameterNames), file = ModelRunIndicatorPath, append = T)


if(EcotypeCalibration == "Y"){
  EcotypeID <- CulData$`ECO#`[3]
  
  Eco.File.origin= readLines(paste0(GD,GenotypeFileName,".ECO"))#, encoding="UTF-8")
  
  if(length(grep("999991 MINIMA", Eco.File.origin)) == 0){
    errorMsg <- "Lower bound (MINIMA) not specified in the ecotype file. Please correct the file."
    return(NULL)
  }
  if(length(grep("999992 MAXIMA", Eco.File.origin)) == 0){
    errorMsg <- "Upper bound (MAXIMA) not specified in the ecotype file. Please correct the file."
    return(NULL)
  }
  if(length(grep("!Calibration", Eco.File.origin)) == 0){
    errorMsg <- "Missing the calibration switches (P/G/N) in the ecotype file. Please correct the file."
    return(NULL)
  }
  
  Eco.CaliLine = Eco.File.origin[which(substr(Eco.File.origin,1,12) == "!Calibration")]
  EcoFile = Eco.File.origin[-which(substr(Eco.File.origin,1,1) == "!")] #ignore lines starting with !
  EcoFile = c(EcoFile,Eco.CaliLine)
  
  if(length(Eco.CaliLine) == 0){
    errorMsg <- "Check Ecotype (.ECO) file format; Missing phenology and growth indicators for calibration"
    write(errorMsg, file = glueWarningLogFile, append = T)
    print(errorMsg)
  }
  
  #locate parameter properties
  Eco.LineNo.title = grep("@ECO#",EcoFile)[1]
  Eco.LineNo.min = grep("999991 MINIMA",EcoFile)
  Eco.LineNo.max = grep("999992 MAXIMA",EcoFile)
  Eco.LineNo.cal = grep("!Calibration",EcoFile)

  Eco.Lineno.thiseco = grep(paste0("^",EcotypeID),EcoFile)
  
  Eco.LineNo.all = c(Eco.LineNo.cal[1],Eco.LineNo.title,Eco.LineNo.min,Eco.LineNo.max,Eco.Lineno.thiseco)
  
  if(length(Eco.LineNo.cal)>1){
    Eco.LineNo.cal = grep("!Calibration",EcoFile)[1]
    warning("Ecotype File - Please use the first !Calibration line to define the calibration switch!")
  }
  
  EcoFile = EcoFile[Eco.LineNo.all]
  write(c("Ecotype Parameter property:",EcoFile ), file = ModelRunIndicatorPath, append = T);
  
  # convert text to dataframe
  EcoFile.df = paste0(substr(EcoFile,1,6), substr(EcoFile,24,nchar(EcoFile)[1]))
  Eco.Header = unlist(strsplit(EcoFile.df[2],split="(\\s|\\|)+"))
  Eco.Header = Eco.Header[which(nchar(Eco.Header)>0)]
  EcoData = read.table(textConnection(EcoFile.df[-c(1,2)]),header=F)
  Eco.Header = Eco.Header[1:length(colnames(EcoData))]
  colnames(EcoData) = Eco.Header
  
  Eco.Cali = unlist(strsplit(EcoFile[1],"\\s+"))
  Eco.Cali.reshape = paste(c(Eco.Cali[1], Eco.Cali[2:length(Eco.Cali)]), sep=" ", collapse = " ")
  Eco.Cali.df = read.table(textConnection(Eco.Cali.reshape),header = F)
  colnames(Eco.Cali.df) = Eco.Header
  Eco.Cali.df = Eco.Cali.df[1:length(Eco.Header)]
  EcoData = rbind(EcoData,Eco.Cali.df)
  
  Eco.ncol.predefined = which(Eco.Header=="@ECO#")
  Eco.TotalParameterNumber = ncol(EcoData) - Eco.ncol.predefined #Get the total number of the parameters.
  Eco.ParameterNames = Eco.Header[-c(1:Eco.ncol.predefined)]
  write(c("Ecotype File Parameters =",Eco.ParameterNames), file = ModelRunIndicatorPath, append = T)
  
  #new row  to identify the origin of each parameter
  CulData[nrow(CulData)+1,] <- "Cultivar"
  EcoData[nrow(EcoData)+1,] <- "Ecotype"
  
  DataColumns <- cbind(CulData, EcoData[-1]) #remove Ecotype first line and merge
  TotalParameterNumber <- Cul.TotalParameterNumber + Eco.TotalParameterNumber
  ParameterNames <- c(Cul.ParameterNames, Eco.ParameterNames)
  EcotypeID <- EcotypeID
  EcotypeParameters <- Eco.TotalParameterNumber #stores ID and number of parameters

}else{
  EcotypeID <- NA
  EcotypeParameters <- 0
  DataColumns <- CulData
  TotalParameterNumber <- Cul.TotalParameterNumber
  ParameterNames <- Cul.ParameterNames
}

#################Step 2: Begin the GLUE procedure.#################
for (i in StartRoundOfGLUE:TotalRoundOfGLUE)
{

RoundOfGLUE<-i;

## (1) Generate random values for the paramter set concerned.
eval(parse(text = paste("source('",WD,"RandomGeneration.r')",sep = '')));
RandomMatrix<-RandomGeneration(WD,DataColumns, TotalParameterNumber, ncol.predefined,NumberOfModelRun, RoundOfGLUE, GLUEFlag);
write(paste0("GLUE Flag: ", RoundOfGLUE), file = ModelRunIndicatorPath, append = T);
write("Random parameter sets have been generated...", file = ModelRunIndicatorPath, append = T);
write("Model runs are starting...", file = ModelRunIndicatorPath, append = T);

calib_var <- "empty"
if(RoundOfGLUE == 1){
  calib_var <- "Phenology"
}else{
  calib_var <- "Growth"
}

print(paste0("GLUE Flag: ", calib_var));
print(paste0("Model runs are starting..."));

## (2) Create new genotype files with the generated parameter sets and run the DSSAT model with them.
eval(parse(text = paste("source('",WD,"ModelRun.r')",sep = '')));
ModelRun(WD, OD, DSSATD, GD, CropName, GenotypeFileName, CultivarID, RoundOfGLUE, TotalParameterNumber, 
          NumberOfModelRun, RandomMatrix, Cores, EcotypeID, EcotypeParameters, ModelSelect, CTR);

print(paste0("GLUE has finished calibrating the ", calib_var," parameters ... Time: ",Sys.time()-time_test))
print(paste0("Initializing evaluation for ", calib_var," parameters ... Time: ",Sys.time()-time_test))

#List every EvaluateFrame file in the output folder
listEvalFrame <- dir(gsub("/$", "", OD), recursive=TRUE, full.names=TRUE, pattern=paste0("EvaluateFrame_",RoundOfGLUE,".txt"));

#Select only EvaluateFrame files in "core..." folders to avoid mixing with results from previous runs contained inside the BackUp folder
EvaluateFiles <- listEvalFrame[grepl(paste0(OD,"core"), listEvalFrame)]

#List every Evaluate_output.txt in the output folder
listEvaluateOut <- dir(gsub("/$", "", OD), recursive=TRUE, full.names=TRUE, pattern=paste0("Evaluate_output.txt"));

#Select only Evaluate_output.txt files in "core..." folders to avoid mixing with results from previous runs contained inside the BackUp folder
EvaluateOutTxt <- listEvaluateOut[grepl(paste0(OD,"core"), listEvaluateOut)]

#List every RealRandomSets file in the output folder
listRealRandomSets <- dir(gsub("/$", "", OD), recursive=TRUE, full.names=TRUE, pattern=paste0("RealRandomSets_",RoundOfGLUE,".txt"));

#Select only RealRandomSets files in "core..." folders to avoid mixing with results from previous runs contained inside the BackUp folder
RealRandomSetsFiles <- listRealRandomSets[grepl(paste0(OD,"core"), listRealRandomSets)]

#List every Error_list file in the output folder
listErrorFrame <- dir(gsub("/$", "", OD), recursive=TRUE, full.names=TRUE, pattern=paste0("Error_list_*"));

#Select only Error_list files in "core..." folders to avoid mixing with results from previous runs contained inside the BackUp folder
ErrorFiles <- listErrorFrame[grepl(paste0(OD,"core"), listErrorFrame)]

EvaluateFrameData <- c();

RealRandomSetsFrame <- c();

ErrorFrame <- c();

#Merge the simulation results from each core
for(Eval_out in EvaluateFiles){
  
  eval(parse(text=paste("FileE<-readLines('",Eval_out,"',n=-1)",sep = '')));
  
  FileLength<-length(FileE);
  
  TitleLine = grep("@RUN",FileE);
  #print(TitleLine)
  
  if(Eval_out==EvaluateFiles[1]){
    EvaluateFrameTitle<-FileE[TitleLine]
    file.copy(EvaluateOutTxt[1], OD) #doing this just because IntegratedLikelihoodCalculation scripts check the header
  }
  
  File_no_title <- FileE[-TitleLine]; #remove title
  
  EvaluateFrameData=append(EvaluateFrameData,File_no_title);
}

EvaluateFrame<-append(EvaluateFrameTitle, EvaluateFrameData);
eval(parse(text = paste('write(EvaluateFrame, "',OD,'/EvaluateFrame_',RoundOfGLUE,'.txt", append = T)',sep="")))

for (Rand_out in RealRandomSetsFiles){
  eval(parse(text=paste("FileRand<-readLines('",Rand_out,"',n=-1)",sep = '')));
  RealRandomSetsFrame=append(RealRandomSetsFrame,FileRand); 
}

eval(parse(text = paste('write(RealRandomSetsFrame, "',OD,'/RealRandomSets_',RoundOfGLUE,'.txt", append = T)',sep="")))

if(length(ErrorFiles) > 0){
  for (Error_out in ErrorFiles){
    eval(parse(text=paste("FileError<-suppressWarnings({readLines('",Error_out,"',n=-1)})",sep = '')));
    ErrorFrame=append(ErrorFrame,FileError); 
  }

eval(parse(text = paste('write(ErrorFrame, "',OD,'/ErrorFrame.txt", append = T)',sep="")))
}
write("Likelihood calculation is starting...", file = ModelRunIndicatorPath, append = T);

## (3) Calculate the likelihood values for each parameter set.
eval(parse(text = paste("source('",WD,"/LikelihoodCalculation.r')",sep = '')));
LikelihoodCalculation(WD, OD, CropName, ParameterNames, RoundOfGLUE);
write("Likelihood calculation is finished...", file = ModelRunIndicatorPath, append = T);
write("Starting calculation of posterior distribution...", file = ModelRunIndicatorPath, append = T);

## (4) Derivation of posterior distribution.
eval(parse(text = paste("source('",WD,"/PosteriorDistribution.r')",sep = '')));
PosteriorDistribution(WD, OD, ParameterNames, ParameterProperty, CropName, RoundOfGLUE);
write("Posterior distribution is derived...", file = ModelRunIndicatorPath, append = T);

## (5)  Indicator of model running to show the round of GLUE is finished.

if (RoundOfGLUE==1)
{
  Indicator<-'The first round of GLUE is finished.';
  write(Indicator, file = ModelRunIndicatorPath, append = T);
} else
{ 
  Indicator<-'The second round of GLUE is finished.';
  write(Indicator, file = ModelRunIndicatorPath, append = T);
}
print(paste0("Finalizing evaluation for ", calib_var," parameters ... Time: ",Sys.time()-time_test))
}

#################Step 3: Get a final optimal parameter set.############## 
eval(parse(text = paste("source('",WD,"/OptimalParameterSet.r')",sep = '')));
OptimalParameterSet(GLUEFlag, OD, DSSATD, CropName, CultivarID, CultivarName, GenotypeFileName, TotalParameterNumber, EcotypeID, EcotypeParameters);

options(show.error.message=T)

#If a DSCSM048.CTR previously existed in the dir, GLUE will put the original back in the folder.
#Otherwise, it will only delete the DSCSM048.CTR that was created for the calibration.
#if(ECTR == TRUE){  
#  writeLines(CTR_file_Original,paste0(DSSATD,"/DSCSM048.CTR"));
#}else{
#  file.remove(paste0(DSSATD,"/DSCSM048.CTR"));
#}

print(Sys.time()-time_test)
print(paste0("Calibration ended at ", Sys.time()))

#print("Cleaning the work directory.")
#unlink(list.files(OD, pattern='core_*', full.names = TRUE),recursive = TRUE)

},error = function(e) {
    fail_run<- paste0("\nAn error occurred during the calibration.\n")
    if(exists("errorMsg") == TRUE){
      fail_run <- paste0(fail_run, errorMsg,"\n")
    }
    
    #Appending R error msg for debugging
    #fail_run<- paste0(fail_run, "\n***\nR error message:\n", e)
    
    write(fail_run, file = glueWarningLogFile, append = T)
    message(paste0(fail_run, e,"\n"))
    #if(OD != WD){
    #  if(ECTR == TRUE){    
    #    writeLines(CTR_file_Original,paste0(DSSATD,"/DSCSM048.CTR"));
    #  }else{
    #    file.remove(paste0(DSSATD,"/DSCSM048.CTR"));
    #  }
    #}
  }
)
